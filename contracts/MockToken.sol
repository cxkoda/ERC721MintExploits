// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0 <0.9.0;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

interface Mintable {
    function mint() external;
}

interface Exploiter {
    function run(Mintable target, uint256 numIterations) external;
}

contract MockToken is ERC721, Mintable {
    uint256 private nextTokenId;

    constructor() ERC721("MockToken", "MOCK") {}

    /// @dev Very naive implementation of a mint function
    /// Allows all explotis
    function mint0() internal {
        _safeMint(msg.sender, nextTokenId++);
    }

    /// @dev Incrementing the counter after minting prevents reentrancy
    function mint1() internal {
        _safeMint(msg.sender, nextTokenId);
        nextTokenId++;
    }

    /// @notice Keeps track when a given sender made the last tx.
    /// @dev This is used and incremented by the `onlyOncePerBlock` modifier.
    mapping(address => uint256) private _lastTxBlockBy;

    /// @dev Reverts if called more than once per block. Only applies to
    /// contracts.
    modifier onlyOncePerBlock() {
        // solhint-disable-next-line avoid-tx-origin
        if (tx.origin != msg.sender) {
            if (block.number <= _lastTxBlockBy[tx.origin])
                revert("OnlyOncePerBlock");
            _lastTxBlockBy[tx.origin] = block.number;
        }
        _;
    }

    /// @dev Prevents reentrancy and looped minting w/ helper contracts
    function mint2() internal onlyOncePerBlock {
        _safeMint(msg.sender, nextTokenId++);
    }

    /// @dev Mint implementation delegator
    function mint() external override {
        // mint0();
        // mint1();
        mint2();
    }
}
